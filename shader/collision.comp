layout (local_size_x = 1) in;

// TODO: represent positions as integers, implicitly divided by some number. then atomicAdd would be applicable

const float rsum = 2.0 * RADIUS;
const float rsum2 = rsum * rsum;
const float epsilon = 0.0001;

void main(void) {
	uint particleIndex = gl_GlobalInvocationID.x;
	vec4 p1 = Particles[particleIndex];
	vec2 pos1 = p1.xy;
	vec2 separation = vec2(0.0);
	for (uint otherIndex = 0; otherIndex < Particles.length(); otherIndex++) {
		if (otherIndex == particleIndex) { continue; }
		vec4 p2 = Particles[otherIndex];
		vec2 pos2 = p2.xy;
		vec2 delta = pos1 - pos2;
		float dist2 = dot(delta, delta);
		if (dist2 >= rsum2) { continue; }
		float dist = sqrt(dist2);
		vec2 normal;
		if (dist < epsilon) {
			dist = 0.0;
			normal = vec2(0.0, 1.0);
		} else {
			normal = delta * (1.0 / dist);
		}
		float overlap = rsum - dist;
		/// change position in loop?
		separation += (0.5 * overlap) * normal;
		// pos1 += separation;
		// pos2 -= (0.5 * overlap) * normal;
		// Particles[i1].xy = pos1;
		// Particles[i2].xy = pos2;
	}
	Separations[particleIndex] = separation;
}

